<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/Dockerfile">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Dockerfile" />
              <option name="updatedContent" value="# Build stage&#10;FROM maven:3.9-eclipse-temurin-21 AS builder&#10;WORKDIR /build&#10;# Copy only the POM first to cache dependencies&#10;COPY pom.xml .&#10;RUN mvn dependency:go-offline&#10;&#10;# Copy source and build&#10;COPY src ./src&#10;RUN mvn clean package -DskipTests&#10;&#10;# Run stage&#10;FROM eclipse-temurin:21-jre-jammy&#10;WORKDIR /app&#10;&#10;# Create non-root user for security&#10;RUN addgroup --system --gid 1001 vertx &amp;&amp; \&#10;    adduser --system --uid 1001 --gid 1001 vertx&#10;&#10;# Copy only the fat JAR from builder stage&#10;COPY --from=builder /build/target/*-fat.jar app.jar&#10;RUN chown -R vertx:vertx /app&#10;&#10;# Switch to non-root user&#10;USER vertx&#10;&#10;# Environment variables&#10;ENV LOG_LEVEL=INFO&#10;ENV SHUTDOWN_TIMEOUT_MS=30000&#10;&#10;# Expose the application port&#10;EXPOSE 8080&#10;&#10;# Set the entry point with Java 21 optimizations&#10;ENTRYPOINT [&quot;java&quot;, \&#10;    &quot;--enable-preview&quot;, \&#10;    &quot;--enable-native-access=ALL-UNNAMED&quot;, \&#10;    &quot;-XX:+UseZGC&quot;, \&#10;    &quot;-XX:+ZGenerational&quot;, \&#10;    &quot;-Djdk.virtualThreadScheduler.parallelism=16&quot;, \&#10;    &quot;-jar&quot;, &quot;app.jar&quot;]" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/monitoring/promtail/promtail-config.yml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/monitoring/promtail/promtail-config.yml" />
              <option name="updatedContent" value="server:&#10;  http_listen_port: 9080&#10;  grpc_listen_port: 0&#10;&#10;positions:&#10;  filename: /tmp/positions.yaml&#10;&#10;clients:&#10;  - url: http://loki:3100/loki/api/v1/push&#10;&#10;scrape_configs:&#10;  - job_name: vertx-logs&#10;    pipeline_stages:&#10;      - json:&#10;          expressions:&#10;            ts: timestamp&#10;            level: level&#10;            logger: logger&#10;            thread: thread&#10;            message: message&#10;      - timestamp:&#10;          source: ts&#10;          format: &quot;2006-01-02 15:04:05.000&quot;&#10;      - labels:&#10;          level:&#10;          logger:&#10;          thread:&#10;    static_configs:&#10;      - targets:&#10;          - localhost&#10;        labels:&#10;          job: vertx&#10;          app: gateway&#10;          __path__: /var/log/vertx/application*.log" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/docker/.dockerignore">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/docker/.dockerignore" />
              <option name="updatedContent" value="# Git&#10;.git&#10;.gitignore&#10;&#10;# Maven&#10;target/&#10;!target/*-fat.jar&#10;dependency-reduced-pom.xml&#10;&#10;# IDE files&#10;.idea/&#10;*.iml&#10;.vscode/&#10;.settings/&#10;.project&#10;.classpath&#10;&#10;# Logs&#10;*.log&#10;&#10;# OS files&#10;.DS_Store&#10;Thumbs.db" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/cresterida/gateway/handlers/AdminServiceHandler.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/cresterida/gateway/handlers/AdminServiceHandler.java" />
              <option name="originalContent" value="package com.cresterida.gateway.handlers;&#10;&#10;import com.cresterida.gateway.model.ServiceDefinition;&#10;import com.cresterida.gateway.ratelimit.TokenBucket;&#10;import com.cresterida.gateway.registry.ServiceRegistry;&#10;import com.cresterida.gateway.util.CounterMetrics;&#10;import io.vertx.core.Handler;&#10;import io.vertx.core.http.HttpHeaders;&#10;import io.vertx.core.json.JsonArray;&#10;import io.vertx.core.json.JsonObject;&#10;import io.vertx.ext.web.Router;&#10;import io.vertx.ext.web.RoutingContext;&#10;import org.slf4j.Logger;&#10;import org.slf4j.LoggerFactory;&#10;&#10;import java.util.List;&#10;import java.util.Map;&#10;import java.util.Optional;&#10;&#10;public class AdminServiceHandler {&#10;    private final ServiceRegistry registry;&#10;    private final Map&lt;String, TokenBucket&gt; limiters;&#10;&#10;    private Logger logger = LoggerFactory.getLogger(AdminServiceHandler.class);&#10;    public AdminServiceHandler(ServiceRegistry registry, Map&lt;String, TokenBucket&gt; limiters) {&#10;        this.registry = registry;&#10;        this.limiters = limiters;&#10;    }&#10;&#10;    public Handler&lt;RoutingContext&gt; withIncrementCounter(Handler&lt;RoutingContext&gt; handler) {&#10;        return CounterMetrics.withMetrics(handler);&#10;    }&#10;&#10;&#10;    public void handleAddService(RoutingContext ctx) {&#10;        try {&#10;            JsonObject body = ctx.body().asJsonObject();&#10;            ServiceDefinition def = ServiceDefinition.fromJson(body);&#10;            registry.add(def);&#10;            limiters.put(def.getId(), new TokenBucket(def.getBurstCapacity(), def.getRateLimitPerSecond()));&#10;            ctx.response().setStatusCode(201)&#10;                    .putHeader(HttpHeaders.CONTENT_TYPE, &quot;application/json&quot;)&#10;                    .end(def.toJson().encode());&#10;        } catch (Exception e) {&#10;            fail(ctx, 400, e.getMessage());&#10;        }&#10;    }&#10;&#10;    public void handleListServices(RoutingContext ctx) {&#10;&#10;        List&lt;ServiceDefinition&gt; list = registry.list();&#10;        JsonArray arr = new JsonArray();&#10;        list.forEach(sd -&gt; arr.add(sd.toJson()));&#10;        ctx.response().putHeader(HttpHeaders.CONTENT_TYPE, &quot;application/json&quot;).end(arr.encode());&#10;    }&#10;&#10;    public void handleGetService(RoutingContext ctx) {&#10;        String id = ctx.pathParam(&quot;id&quot;);&#10;        logger.info(&quot;Fetching service with id: {}&quot;, id);&#10;&#10;        registry.getById(id)&#10;                .ifPresentOrElse(sd -&gt; ctx.response()&#10;                        .putHeader(HttpHeaders.CONTENT_TYPE, &quot;application/json&quot;)&#10;                        .end(sd.toJson().encode()),&#10;                    () -&gt; fail(ctx, 404, &quot;Service not found&quot;));&#10;    }&#10;&#10;    public void handleUpdateService(RoutingContext ctx) {&#10;        String id = ctx.pathParam(&quot;id&quot;);&#10;        try {&#10;            JsonObject body = ctx.body().asJsonObject();&#10;            ServiceDefinition incoming = ServiceDefinition.fromJson(body.put(&quot;id&quot;, id));&#10;            Optional&lt;ServiceDefinition&gt; updated = registry.update(id, incoming);&#10;            if (updated.isEmpty()) {&#10;                fail(ctx, 404, &quot;Service not found&quot;);&#10;                return;&#10;            }&#10;            ServiceDefinition def = updated.get();&#10;            limiters.put(def.getId(), new TokenBucket(def.getBurstCapacity(), def.getRateLimitPerSecond()));&#10;            ctx.response().putHeader(HttpHeaders.CONTENT_TYPE, &quot;application/json&quot;).end(def.toJson().encode());&#10;        } catch (Exception e) {&#10;            fail(ctx, 400, e.getMessage());&#10;        }&#10;    }&#10;&#10;    public void handleDeleteService(RoutingContext ctx) {&#10;        String id = ctx.pathParam(&quot;id&quot;);&#10;        Optional&lt;ServiceDefinition&gt; removed = registry.remove(id);&#10;        if (removed.isPresent()) {&#10;            limiters.remove(id);&#10;            ctx.response().setStatusCode(204).end();&#10;        } else {&#10;            fail(ctx, 404, &quot;Service not found&quot;);&#10;        }&#10;    }&#10;&#10;    private void fail(RoutingContext ctx, int status, String message) {&#10;        JsonObject err = new JsonObject()&#10;                .put(&quot;error&quot;, message)&#10;                .put(&quot;status&quot;, status)&#10;                .put(&quot;path&quot;, ctx.request().path());&#10;        ctx.response().setStatusCode(status)&#10;                .putHeader(HttpHeaders.CONTENT_TYPE, &quot;application/json&quot;)&#10;                .end(err.encode());&#10;    }&#10;&#10;    public  void registerRoutes(Router router)&#10;    {&#10;        router.post(&quot;/admin/services&quot;).handler(this::handleListServices);&#10;        router.get(&quot;/admin/services&quot;).handler(CounterMetrics.withMetrics(this::handleListServices));&#10;        router.get(&quot;/admin/services/:id&quot;).handler(CounterMetrics.withMetrics(this::handleGetService));&#10;        router.put(&quot;/admin/services/:id&quot;).handler(this::handleUpdateService);&#10;        router.delete(&quot;/admin/services/:id&quot;).handler(this::handleDeleteService);&#10;&#10;&#10;    }&#10;&#10;&#10;}&#10;&#10;" />
              <option name="updatedContent" value="package com.cresterida.gateway.handlers;&#10;&#10;import com.cresterida.gateway.model.ServiceDefinition;&#10;import com.cresterida.gateway.model.ServiceInstance;&#10;import com.cresterida.gateway.ratelimit.TokenBucket;&#10;import com.cresterida.gateway.registry.ServiceRegistry;&#10;import com.cresterida.gateway.util.CounterMetrics;&#10;import io.vertx.core.Handler;&#10;import io.vertx.core.http.HttpHeaders;&#10;import io.vertx.core.json.JsonArray;&#10;import io.vertx.core.json.JsonObject;&#10;import io.vertx.ext.web.Router;&#10;import io.vertx.ext.web.RoutingContext;&#10;import org.slf4j.Logger;&#10;import org.slf4j.LoggerFactory;&#10;&#10;import java.util.List;&#10;import java.util.Map;&#10;import java.util.Optional;&#10;&#10;public class AdminServiceHandler {&#10;    private final ServiceRegistry registry;&#10;    private final Map&lt;String, TokenBucket&gt; limiters;&#10;&#10;    private final Logger logger = LoggerFactory.getLogger(AdminServiceHandler.class);&#10;    public AdminServiceHandler(ServiceRegistry registry, Map&lt;String, TokenBucket&gt; limiters) {&#10;        this.registry = registry;&#10;        this.limiters = limiters;&#10;    }&#10;&#10;    public Handler&lt;RoutingContext&gt; withIncrementCounter(Handler&lt;RoutingContext&gt; handler) {&#10;        return CounterMetrics.withMetrics(handler);&#10;    }&#10;&#10;&#10;    public void handleAddService(RoutingContext ctx) {&#10;        try {&#10;            JsonObject body = ctx.body().asJsonObject();&#10;            ServiceDefinition def = new ServiceDefinition.Builder()&#10;                .setId(body.getString(&quot;id&quot;))&#10;                .setName(body.getString(&quot;name&quot;))&#10;                .setPackage(body.getString(&quot;packageName&quot;))&#10;                .setVersion(body.getString(&quot;version&quot;))&#10;                .setProtoDefinition(body.getString(&quot;protoDefinition&quot;))&#10;                .setBurstCapacity(body.getInteger(&quot;burstCapacity&quot;, 100))&#10;                .setRateLimitPerSecond(body.getInteger(&quot;rateLimitPerSecond&quot;, 10))&#10;                .build();&#10;&#10;            registry.add(def);&#10;            limiters.put(def.getId(), new TokenBucket(def.getBurstCapacity(), def.getRateLimitPerSecond()));&#10;            ctx.response().setStatusCode(201)&#10;                    .putHeader(HttpHeaders.CONTENT_TYPE, &quot;application/json&quot;)&#10;                    .end(def.toJson().encode());&#10;        } catch (Exception e) {&#10;            fail(ctx, 400, e.getMessage());&#10;        }&#10;    }&#10;&#10;    public void handleListServices(RoutingContext ctx) {&#10;&#10;        List&lt;ServiceDefinition&gt; list = registry.list();&#10;        JsonArray arr = new JsonArray();&#10;        list.forEach(sd -&gt; arr.add(sd.toJson()));&#10;        ctx.response().putHeader(HttpHeaders.CONTENT_TYPE, &quot;application/json&quot;).end(arr.encode());&#10;    }&#10;&#10;    public void handleGetService(RoutingContext ctx) {&#10;        String id = ctx.pathParam(&quot;id&quot;);&#10;        logger.info(&quot;Fetching service with id: {}&quot;, id);&#10;&#10;        registry.getById(id)&#10;                .ifPresentOrElse(sd -&gt; ctx.response()&#10;                        .putHeader(HttpHeaders.CONTENT_TYPE, &quot;application/json&quot;)&#10;                        .end(sd.toJson().encode()),&#10;                    () -&gt; fail(ctx, 404, &quot;Service not found&quot;));&#10;    }&#10;&#10;    public void handleUpdateService(RoutingContext ctx) {&#10;        String id = ctx.pathParam(&quot;id&quot;);&#10;        try {&#10;            JsonObject body = ctx.body().asJsonObject();&#10;            ServiceDefinition incoming = new ServiceDefinition.Builder()&#10;                .setId(id)&#10;                .setName(body.getString(&quot;name&quot;))&#10;                .setPackage(body.getString(&quot;packageName&quot;))&#10;                .setVersion(body.getString(&quot;version&quot;))&#10;                .setProtoDefinition(body.getString(&quot;protoDefinition&quot;))&#10;                .setBurstCapacity(body.getInteger(&quot;burstCapacity&quot;, 100))&#10;                .setRateLimitPerSecond(body.getInteger(&quot;rateLimitPerSecond&quot;, 10))&#10;                .build();&#10;&#10;            Optional&lt;ServiceDefinition&gt; updated = registry.update(id, incoming);&#10;            if (updated.isEmpty()) {&#10;                fail(ctx, 404, &quot;Service not found&quot;);&#10;                return;&#10;            }&#10;            ServiceDefinition def = updated.get();&#10;            limiters.put(def.getId(), new TokenBucket(def.getBurstCapacity(), def.getRateLimitPerSecond()));&#10;            ctx.response().putHeader(HttpHeaders.CONTENT_TYPE, &quot;application/json&quot;).end(def.toJson().encode());&#10;        } catch (Exception e) {&#10;            fail(ctx, 400, e.getMessage());&#10;        }&#10;    }&#10;&#10;    public void handleDeleteService(RoutingContext ctx) {&#10;        String id = ctx.pathParam(&quot;id&quot;);&#10;        Optional&lt;ServiceDefinition&gt; removed = registry.remove(id);&#10;        if (removed.isPresent()) {&#10;            limiters.remove(id);&#10;            ctx.response().setStatusCode(204).end();&#10;        } else {&#10;            fail(ctx, 404, &quot;Service not found&quot;);&#10;        }&#10;    }&#10;&#10;    private void fail(RoutingContext ctx, int status, String message) {&#10;        JsonObject err = new JsonObject()&#10;                .put(&quot;error&quot;, message)&#10;                .put(&quot;status&quot;, status)&#10;                .put(&quot;path&quot;, ctx.request().path());&#10;        ctx.response().setStatusCode(status)&#10;                .putHeader(HttpHeaders.CONTENT_TYPE, &quot;application/json&quot;)&#10;                .end(err.encode());&#10;    }&#10;&#10;    public  void registerRoutes(Router router)&#10;    {&#10;        router.post(&quot;/admin/services&quot;).handler(this::handleAddService);&#10;        router.get(&quot;/admin/services&quot;).handler(CounterMetrics.withMetrics(this::handleListServices));&#10;        router.get(&quot;/admin/services/:id&quot;).handler(CounterMetrics.withMetrics(this::handleGetService));&#10;        router.put(&quot;/admin/services/:id&quot;).handler(this::handleUpdateService);&#10;        router.delete(&quot;/admin/services/:id&quot;).handler(this::handleDeleteService);&#10;&#10;&#10;    }&#10;&#10;&#10;}&#10;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/cresterida/gateway/model/ServiceDefinition.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/cresterida/gateway/model/ServiceDefinition.java" />
              <option name="originalContent" value="&#10;" />
              <option name="updatedContent" value="package com.cresterida.gateway.model;&#10;&#10;import io.vertx.core.json.JsonObject;&#10;import io.vertx.core.json.JsonArray;&#10;import java.util.List;&#10;import java.util.ArrayList;&#10;import java.util.Map;&#10;import java.util.HashMap;&#10;import java.util.Collections;&#10;import java.net.URI;&#10;&#10;public class ServiceDefinition {&#10;    private final String id;&#10;    private final String name;&#10;    private final String packageName;&#10;    private final String version;&#10;    private final String protoDefinition;&#10;    private final List&lt;ServiceInstance&gt; instances;&#10;    private final Map&lt;String, EndpointDefinition&gt; endpoints;&#10;    private final int burstCapacity;&#10;    private final int rateLimitPerSecond;&#10;    private final Map&lt;String, JsonFieldMapping&gt; fieldMappings;&#10;    private final String pathPrefix;&#10;    private final String upstreamBaseUrl;&#10;    private final boolean stripPrefix;&#10;&#10;    private ServiceDefinition(Builder builder) {&#10;        this.id = builder.id;&#10;        this.name = builder.name;&#10;        this.packageName = builder.packageName;&#10;        this.version = builder.version;&#10;        this.protoDefinition = builder.protoDefinition;&#10;        this.instances = new ArrayList&lt;&gt;(builder.instances);&#10;        this.endpoints = new HashMap&lt;&gt;(builder.endpoints);&#10;        this.burstCapacity = builder.burstCapacity;&#10;        this.rateLimitPerSecond = builder.rateLimitPerSecond;&#10;        this.fieldMappings = new HashMap&lt;&gt;(builder.fieldMappings);&#10;        this.pathPrefix = builder.pathPrefix;&#10;        this.upstreamBaseUrl = builder.upstreamBaseUrl;&#10;        this.stripPrefix = builder.stripPrefix;&#10;    }&#10;&#10;    public static ServiceDefinition fromJson(JsonObject json) {&#10;        if (json == null) {&#10;            throw new IllegalArgumentException(&quot;JSON cannot be null&quot;);&#10;        }&#10;&#10;        Builder builder = new Builder()&#10;            .setId(json.getString(&quot;id&quot;))&#10;            .setName(json.getString(&quot;name&quot;))&#10;            .setPackage(json.getString(&quot;packageName&quot;))&#10;            .setVersion(json.getString(&quot;version&quot;))&#10;            .setProtoDefinition(json.getString(&quot;protoDefinition&quot;))&#10;            .setBurstCapacity(json.getInteger(&quot;burstCapacity&quot;, 100))&#10;            .setRateLimitPerSecond(json.getInteger(&quot;rateLimitPerSecond&quot;, 10))&#10;            .setPathPrefix(json.getString(&quot;pathPrefix&quot;, &quot;/&quot;))&#10;            .setUpstreamBaseUrl(json.getString(&quot;upstreamBaseUrl&quot;))&#10;            .setStripPrefix(json.getBoolean(&quot;stripPrefix&quot;, false));&#10;&#10;        if (json.containsKey(&quot;instances&quot;)) {&#10;            JsonArray instances = json.getJsonArray(&quot;instances&quot;);&#10;            if (instances != null) {&#10;                instances.forEach(inst -&gt; {&#10;                    if (inst instanceof JsonObject) {&#10;                        JsonObject instObj = (JsonObject) inst;&#10;                        builder.addInstance(new ServiceInstance(&#10;                            instObj.getString(&quot;host&quot;),&#10;                            instObj.getInteger(&quot;port&quot;)&#10;                        ));&#10;                    }&#10;                });&#10;            }&#10;        }&#10;&#10;        return builder.build();&#10;    }&#10;&#10;    public JsonObject toJson() {&#10;        JsonObject json = new JsonObject()&#10;            .put(&quot;id&quot;, id)&#10;            .put(&quot;name&quot;, name)&#10;            .put(&quot;packageName&quot;, packageName)&#10;            .put(&quot;version&quot;, version)&#10;            .put(&quot;protoDefinition&quot;, protoDefinition)&#10;            .put(&quot;burstCapacity&quot;, burstCapacity)&#10;            .put(&quot;rateLimitPerSecond&quot;, rateLimitPerSecond)&#10;            .put(&quot;pathPrefix&quot;, pathPrefix)&#10;            .put(&quot;upstreamBaseUrl&quot;, upstreamBaseUrl)&#10;            .put(&quot;stripPrefix&quot;, stripPrefix);&#10;&#10;        if (!instances.isEmpty()) {&#10;            JsonArray instancesArray = new JsonArray();&#10;            instances.forEach(instance -&gt; {&#10;                instancesArray.add(instance.toJson());&#10;            });&#10;            json.put(&quot;instances&quot;, instancesArray);&#10;        }&#10;&#10;        return json;&#10;    }&#10;&#10;    // Getters&#10;    public String getId() { return id; }&#10;    public String getName() { return name; }&#10;    public String getPackage() { return packageName; }&#10;    public String getVersion() { return version; }&#10;    public String getProtoDefinition() { return protoDefinition; }&#10;    public List&lt;ServiceInstance&gt; getInstances() { return Collections.unmodifiableList(instances); }&#10;    public ServiceInstance getActiveInstance() {&#10;        return instances.stream()&#10;            .filter(instance -&gt; &quot;UP&quot;.equals(instance.getHealth()))&#10;            .findFirst()&#10;            .orElse(null);&#10;    }&#10;    public Map&lt;String, EndpointDefinition&gt; getEndpoints() { return Collections.unmodifiableMap(endpoints); }&#10;    public EndpointDefinition getEndpoint(String name) { return endpoints.get(name); }&#10;    public int getBurstCapacity() { return burstCapacity; }&#10;    public int getRateLimitPerSecond() { return rateLimitPerSecond; }&#10;    public Map&lt;String, JsonFieldMapping&gt; getFieldMappings() { return Collections.unmodifiableMap(fieldMappings); }&#10;    public String getPathPrefix() { return pathPrefix; }&#10;    public String getUpstreamBaseUrl() { return upstreamBaseUrl; }&#10;    public boolean isStripPrefix() { return stripPrefix; }&#10;&#10;    public static class Builder {&#10;        private String id;&#10;        private String name;&#10;        private String packageName;&#10;        private String version;&#10;        private String protoDefinition;&#10;        private List&lt;ServiceInstance&gt; instances = new ArrayList&lt;&gt;();&#10;        private Map&lt;String, EndpointDefinition&gt; endpoints = new HashMap&lt;&gt;();&#10;        private int burstCapacity = 100;&#10;        private int rateLimitPerSecond = 10;&#10;        private Map&lt;String, JsonFieldMapping&gt; fieldMappings = new HashMap&lt;&gt;();&#10;        private String pathPrefix = &quot;/&quot;;&#10;        private String upstreamBaseUrl;&#10;        private boolean stripPrefix = false;&#10;&#10;        public Builder setId(String id) { this.id = id; return this; }&#10;        public Builder setName(String name) { this.name = name; return this; }&#10;        public Builder setPackage(String packageName) { this.packageName = packageName; return this; }&#10;        public Builder setVersion(String version) { this.version = version; return this; }&#10;        public Builder setProtoDefinition(String protoDefinition) { this.protoDefinition = protoDefinition; return this; }&#10;        public Builder addInstance(ServiceInstance instance) { this.instances.add(instance); return this; }&#10;        public Builder setBurstCapacity(int burstCapacity) { this.burstCapacity = burstCapacity; return this; }&#10;        public Builder setRateLimitPerSecond(int rateLimitPerSecond) { this.rateLimitPerSecond = rateLimitPerSecond; return this; }&#10;        public Builder setPathPrefix(String pathPrefix) { this.pathPrefix = pathPrefix; return this; }&#10;        public Builder setUpstreamBaseUrl(String upstreamBaseUrl) { this.upstreamBaseUrl = upstreamBaseUrl; return this; }&#10;        public Builder setStripPrefix(boolean stripPrefix) { this.stripPrefix = stripPrefix; return this; }&#10;&#10;        public ServiceDefinition build() {&#10;            return new ServiceDefinition(this);&#10;        }&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/cresterida/gateway/model/ServiceInstance.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/cresterida/gateway/model/ServiceInstance.java" />
              <option name="updatedContent" value="package com.cresterida.gateway.model;&#10;&#10;import io.vertx.core.json.JsonObject;&#10;&#10;public class ServiceInstance {&#10;    private String host;&#10;    private int port;&#10;    private String health;&#10;&#10;    public ServiceInstance(String host, int port) {&#10;        this.host = host;&#10;        this.port = port;&#10;        this.health = &quot;UP&quot;;&#10;    }&#10;&#10;    public String getHost() {&#10;        return host;&#10;    }&#10;&#10;    public int getPort() {&#10;        return port;&#10;    }&#10;&#10;    public String getHealth() {&#10;        return health;&#10;    }&#10;&#10;    public void setHealth(String health) {&#10;        this.health = health;&#10;    }&#10;&#10;    public JsonObject toJson() {&#10;        return new JsonObject()&#10;            .put(&quot;host&quot;, host)&#10;            .put(&quot;port&quot;, port)&#10;            .put(&quot;health&quot;, health);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/cresterida/gateway/registry/ServiceRegistry.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/cresterida/gateway/registry/ServiceRegistry.java" />
              <option name="updatedContent" value="package com.cresterida.gateway.registry;&#10;&#10;import com.cresterida.gateway.model.ServiceDefinition;&#10;import java.util.List;&#10;import java.util.Map;&#10;import java.util.Optional;&#10;import java.util.concurrent.ConcurrentHashMap;&#10;import java.util.stream.Collectors;&#10;&#10;public class ServiceRegistry {&#10;    private final Map&lt;String, ServiceDefinition&gt; services = new ConcurrentHashMap&lt;&gt;();&#10;&#10;    public void add(ServiceDefinition service) {&#10;        services.put(service.getId(), service);&#10;    }&#10;&#10;    public Optional&lt;ServiceDefinition&gt; getById(String id) {&#10;        return Optional.ofNullable(services.get(id));&#10;    }&#10;&#10;    public List&lt;ServiceDefinition&gt; list() {&#10;        return List.copyOf(services.values());&#10;    }&#10;&#10;    public Optional&lt;ServiceDefinition&gt; update(String id, ServiceDefinition service) {&#10;        if (services.containsKey(id)) {&#10;            services.put(id, service);&#10;            return Optional.of(service);&#10;        }&#10;        return Optional.empty();&#10;    }&#10;&#10;    public Optional&lt;ServiceDefinition&gt; remove(String id) {&#10;        return Optional.ofNullable(services.remove(id));&#10;    }&#10;&#10;    public Optional&lt;ServiceDefinition&gt; resolveByPath(String path) {&#10;        return services.values().stream()&#10;            .filter(service -&gt; path.startsWith(service.getPathPrefix()))&#10;            .findFirst();&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>