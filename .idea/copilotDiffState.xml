<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/Dockerfile">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Dockerfile" />
              <option name="updatedContent" value="# Build stage&#10;FROM maven:3.9-eclipse-temurin-21 AS builder&#10;WORKDIR /build&#10;# Copy only the POM first to cache dependencies&#10;COPY pom.xml .&#10;RUN mvn dependency:go-offline&#10;&#10;# Copy source and build&#10;COPY src ./src&#10;RUN mvn clean package -DskipTests&#10;&#10;# Run stage&#10;FROM eclipse-temurin:21-jre-jammy&#10;WORKDIR /app&#10;&#10;# Create non-root user for security&#10;RUN addgroup --system --gid 1001 vertx &amp;&amp; \&#10;    adduser --system --uid 1001 --gid 1001 vertx&#10;&#10;# Copy only the fat JAR from builder stage&#10;COPY --from=builder /build/target/*-fat.jar app.jar&#10;RUN chown -R vertx:vertx /app&#10;&#10;# Switch to non-root user&#10;USER vertx&#10;&#10;# Environment variables&#10;ENV LOG_LEVEL=INFO&#10;ENV SHUTDOWN_TIMEOUT_MS=30000&#10;&#10;# Expose the application port&#10;EXPOSE 8080&#10;&#10;# Set the entry point with Java 21 optimizations&#10;ENTRYPOINT [&quot;java&quot;, \&#10;    &quot;--enable-preview&quot;, \&#10;    &quot;--enable-native-access=ALL-UNNAMED&quot;, \&#10;    &quot;-XX:+UseZGC&quot;, \&#10;    &quot;-XX:+ZGenerational&quot;, \&#10;    &quot;-Djdk.virtualThreadScheduler.parallelism=16&quot;, \&#10;    &quot;-jar&quot;, &quot;app.jar&quot;]" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/monitoring/promtail/promtail-config.yml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/monitoring/promtail/promtail-config.yml" />
              <option name="updatedContent" value="server:&#10;  http_listen_port: 9080&#10;  grpc_listen_port: 0&#10;&#10;positions:&#10;  filename: /tmp/positions.yaml&#10;&#10;clients:&#10;  - url: http://loki:3100/loki/api/v1/push&#10;&#10;scrape_configs:&#10;  - job_name: vertx-logs&#10;    pipeline_stages:&#10;      - json:&#10;          expressions:&#10;            ts: timestamp&#10;            level: level&#10;            logger: logger&#10;            thread: thread&#10;            message: message&#10;      - timestamp:&#10;          source: ts&#10;          format: &quot;2006-01-02 15:04:05.000&quot;&#10;      - labels:&#10;          level:&#10;          logger:&#10;          thread:&#10;    static_configs:&#10;      - targets:&#10;          - localhost&#10;        labels:&#10;          job: vertx&#10;          app: gateway&#10;          __path__: /var/log/vertx/application*.log" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/cresterida/gateway/ApiGatewayVerticle.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/cresterida/gateway/ApiGatewayVerticle.java" />
              <option name="originalContent" value="&#10;" />
              <option name="updatedContent" value="package com.cresterida.gateway;&#10;&#10;import com.cresterida.gateway.handlers.AdminServiceHandler;&#10;import com.cresterida.gateway.handlers.DynamicGrpcProxyHandler;&#10;import com.cresterida.gateway.handlers.HttpProxyHandler;&#10;import com.cresterida.gateway.model.ServiceType;&#10;import com.cresterida.gateway.ratelimit.TokenBucket;&#10;import com.cresterida.gateway.registry.ServiceRegistry;&#10;import java.util.concurrent.ConcurrentHashMap;&#10;import io.vertx.core.AbstractVerticle;&#10;import io.vertx.core.Promise;&#10;import io.vertx.core.json.JsonObject;&#10;import io.vertx.ext.web.Router;&#10;import io.vertx.ext.web.handler.BodyHandler;&#10;import org.apache.logging.log4j.LogManager;&#10;import org.apache.logging.log4j.Logger;&#10;&#10;public class ApiGatewayVerticle extends AbstractVerticle {&#10;    private static final Logger LOGGER = LogManager.getLogger(ApiGatewayVerticle.class);&#10;    private static final int DEFAULT_PORT = 8080;&#10;&#10;    private ServiceRegistry registry;&#10;    private AdminServiceHandler adminHandler;&#10;    private DynamicGrpcProxyHandler grpcHandler;&#10;    private HttpProxyHandler httpHandler;&#10;    private final ConcurrentHashMap&lt;String, TokenBucket&gt; rateLimiters = new ConcurrentHashMap&lt;&gt;();&#10;&#10;    @Override&#10;    public void start(Promise&lt;Void&gt; startPromise) {&#10;        // Initialize components&#10;        registry = new ServiceRegistry();&#10;        adminHandler = new AdminServiceHandler(registry, rateLimiters);&#10;        grpcHandler = new DynamicGrpcProxyHandler(vertx);&#10;        httpHandler = new HttpProxyHandler(vertx);&#10;&#10;        // Create router&#10;        Router router = Router.router(vertx);&#10;        router.route().handler(BodyHandler.create());&#10;&#10;        // Admin routes&#10;        setupAdminRoutes(router);&#10;&#10;        // API routes with service type routing&#10;        setupApiRoutes(router);&#10;&#10;        // Start the server&#10;        vertx.createHttpServer()&#10;            .requestHandler(router)&#10;            .listen(config().getInteger(&quot;http.port&quot;, DEFAULT_PORT))&#10;            .onSuccess(server -&gt; {&#10;                LOGGER.info(&quot;Gateway started on port {}&quot;, server.actualPort());&#10;                startPromise.complete();&#10;            })&#10;            .onFailure(startPromise::fail);&#10;    }&#10;&#10;    private void setupAdminRoutes(Router router) {&#10;        router.post(&quot;/admin/services&quot;).handler(adminHandler::handleAddService);&#10;        router.get(&quot;/admin/services&quot;).handler(adminHandler::handleListServices);&#10;        router.get(&quot;/admin/services/:id&quot;).handler(adminHandler::handleGetService);&#10;        router.put(&quot;/admin/services/:id&quot;).handler(adminHandler::handleUpdateService);&#10;        router.delete(&quot;/admin/services/:id&quot;).handler(adminHandler::handleDeleteService);&#10;    }&#10;&#10;    private void setupApiRoutes(Router router) {&#10;        router.route(&quot;/api/*&quot;).handler(ctx -&gt; {&#10;            String path = ctx.request().path();&#10;&#10;            // Try to resolve the service first&#10;            registry.resolveByPath(path).ifPresentOrElse(service -&gt; {&#10;                // Set service in context for handlers to use&#10;                ctx.put(&quot;service&quot;, service);&#10;&#10;                // Route based on service type&#10;                if (service.getType() == ServiceType.GRPC) {&#10;                    LOGGER.debug(&quot;Routing to gRPC handler: {}&quot;, path);&#10;                    grpcHandler.handle(ctx);&#10;                } else {&#10;                    LOGGER.debug(&quot;Routing to HTTP handler: {}&quot;, path);&#10;                    httpHandler.handle(ctx);&#10;                }&#10;            }, () -&gt; {&#10;                // No service found for this path&#10;                LOGGER.warn(&quot;No service found for path: {}&quot;, path);&#10;                ctx.response()&#10;                    .setStatusCode(404)&#10;                    .putHeader(&quot;Content-Type&quot;, &quot;application/json&quot;)&#10;                    .end(new JsonObject()&#10;                        .put(&quot;error&quot;, &quot;No service found for path: &quot; + path)&#10;                        .put(&quot;status&quot;, 404)&#10;                        .encode());&#10;            });&#10;        });&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>