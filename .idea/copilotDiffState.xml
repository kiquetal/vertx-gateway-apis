<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/Dockerfile">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Dockerfile" />
              <option name="updatedContent" value="# Build stage&#10;FROM maven:3.9-eclipse-temurin-21 AS builder&#10;WORKDIR /build&#10;# Copy only the POM first to cache dependencies&#10;COPY pom.xml .&#10;RUN mvn dependency:go-offline&#10;&#10;# Copy source and build&#10;COPY src ./src&#10;RUN mvn clean package -DskipTests&#10;&#10;# Run stage&#10;FROM eclipse-temurin:21-jre-jammy&#10;WORKDIR /app&#10;&#10;# Create non-root user for security&#10;RUN addgroup --system --gid 1001 vertx &amp;&amp; \&#10;    adduser --system --uid 1001 --gid 1001 vertx&#10;&#10;# Copy only the fat JAR from builder stage&#10;COPY --from=builder /build/target/*-fat.jar app.jar&#10;RUN chown -R vertx:vertx /app&#10;&#10;# Switch to non-root user&#10;USER vertx&#10;&#10;# Environment variables&#10;ENV LOG_LEVEL=INFO&#10;ENV SHUTDOWN_TIMEOUT_MS=30000&#10;&#10;# Expose the application port&#10;EXPOSE 8080&#10;&#10;# Set the entry point with Java 21 optimizations&#10;ENTRYPOINT [&quot;java&quot;, \&#10;    &quot;--enable-preview&quot;, \&#10;    &quot;--enable-native-access=ALL-UNNAMED&quot;, \&#10;    &quot;-XX:+UseZGC&quot;, \&#10;    &quot;-XX:+ZGenerational&quot;, \&#10;    &quot;-Djdk.virtualThreadScheduler.parallelism=16&quot;, \&#10;    &quot;-jar&quot;, &quot;app.jar&quot;]" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/monitoring/promtail/promtail-config.yml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/monitoring/promtail/promtail-config.yml" />
              <option name="updatedContent" value="server:&#10;  http_listen_port: 9080&#10;  grpc_listen_port: 0&#10;&#10;positions:&#10;  filename: /tmp/positions.yaml&#10;&#10;clients:&#10;  - url: http://loki:3100/loki/api/v1/push&#10;&#10;scrape_configs:&#10;  - job_name: vertx-logs&#10;    pipeline_stages:&#10;      - json:&#10;          expressions:&#10;            ts: timestamp&#10;            level: level&#10;            logger: logger&#10;            thread: thread&#10;            message: message&#10;      - timestamp:&#10;          source: ts&#10;          format: &quot;2006-01-02 15:04:05.000&quot;&#10;      - labels:&#10;          level:&#10;          logger:&#10;          thread:&#10;    static_configs:&#10;      - targets:&#10;          - localhost&#10;        labels:&#10;          job: vertx&#10;          app: gateway&#10;          __path__: /var/log/vertx/application*.log" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/docker/.dockerignore">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/docker/.dockerignore" />
              <option name="updatedContent" value="# Git&#10;.git&#10;.gitignore&#10;&#10;# Maven&#10;target/&#10;!target/*-fat.jar&#10;dependency-reduced-pom.xml&#10;&#10;# IDE files&#10;.idea/&#10;*.iml&#10;.vscode/&#10;.settings/&#10;.project&#10;.classpath&#10;&#10;# Logs&#10;*.log&#10;&#10;# OS files&#10;.DS_Store&#10;Thumbs.db" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/cresterida/gateway/util/ClientCalls.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/cresterida/gateway/util/ClientCalls.java" />
              <option name="originalContent" value="package com.cresterida.gateway.util;&#10;&#10;import com.google.protobuf.DescriptorProtos;&#10;import com.google.protobuf.Descriptors;&#10;import com.google.protobuf.DynamicMessage;&#10;import com.google.protobuf.Message;&#10;import io.grpc.ManagedChannel;&#10;import io.grpc.ManagedChannelBuilder;&#10;import io.grpc.MethodDescriptor;&#10;import org.slf4j.Logger;&#10;import org.slf4j.LoggerFactory;&#10;&#10;public class ClientCalls {&#10;    private static final Logger LOGGER = LoggerFactory.getLogger(ClientCalls.class);&#10;&#10;    public static Message makeUnaryCall(&#10;            String host,&#10;            int port,&#10;            String serviceName,&#10;            String methodName,&#10;            Message request,&#10;            DescriptorProtos.FileDescriptorProto fileDescriptor) {&#10;        try {&#10;            // Create channel&#10;            ManagedChannel channel = ManagedChannelBuilder.forAddress(host, port)&#10;                    .usePlaintext()&#10;                    .build();&#10;&#10;            // Get service descriptor&#10;            Descriptors.FileDescriptor fileDesc = Descriptors.FileDescriptor.buildFrom(fileDescriptor, new Descriptors.FileDescriptor[]{});&#10;            Descriptors.ServiceDescriptor serviceDescriptor = fileDesc.findServiceByName(serviceName);&#10;&#10;            // Get method descriptor&#10;            Descriptors.MethodDescriptor methodDescriptor = serviceDescriptor.findMethodByName(methodName);&#10;&#10;            if (methodDescriptor == null) {&#10;                throw new IllegalArgumentException(&quot;Method not found: &quot; + methodName);&#10;            }&#10;&#10;            // Create gRPC method descriptor&#10;            MethodDescriptor&lt;Message, Message&gt; grpcMethodDescriptor = MethodDescriptor.&lt;Message, Message&gt;newBuilder()&#10;                    .setType(MethodDescriptor.MethodType.UNARY)&#10;                    .setFullMethodName(MethodDescriptor.generateFullMethodName(serviceName, methodName))&#10;                    .setRequestMarshaller(new DynamicMessageMarshaller(methodDescriptor.getInputType()))&#10;                    .setResponseMarshaller(new DynamicMessageMarshaller(methodDescriptor.getOutputType()))&#10;                    .build();&#10;&#10;            // Make the call&#10;            return io.grpc.stub.ClientCalls.blockingUnaryCall(channel, grpcMethodDescriptor, io.grpc.CallOptions.DEFAULT, request);&#10;&#10;        } catch (Exception e) {&#10;            LOGGER.error(&quot;Error making gRPC call&quot;, e);&#10;            throw new RuntimeException(&quot;Failed to make gRPC call&quot;, e);&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.cresterida.gateway.util;&#10;&#10;import com.google.protobuf.DescriptorProtos;&#10;import com.google.protobuf.Descriptors;&#10;import com.google.protobuf.DynamicMessage;&#10;import com.google.protobuf.Message;&#10;import io.grpc.ManagedChannel;&#10;import io.grpc.ManagedChannelBuilder;&#10;import io.grpc.MethodDescriptor;&#10;import org.slf4j.Logger;&#10;import org.slf4j.LoggerFactory;&#10;&#10;public class ClientCalls {&#10;    private static final Logger LOGGER = LoggerFactory.getLogger(ClientCalls.class);&#10;&#10;    public static Message makeUnaryCall(&#10;            String host,&#10;            int port,&#10;            String serviceName,&#10;            String methodName,&#10;            Message request,&#10;            DescriptorProtos.FileDescriptorProto fileDescriptor) {&#10;        try {&#10;            // Create channel&#10;            ManagedChannel channel = ManagedChannelBuilder.forAddress(host, port)&#10;                    .usePlaintext()&#10;                    .build();&#10;&#10;            // Get service descriptor&#10;            Descriptors.FileDescriptor fileDesc = Descriptors.FileDescriptor.buildFrom(fileDescriptor, new Descriptors.FileDescriptor[]{});&#10;            // Extract just the service name without the package&#10;            String simpleServiceName = serviceName.substring(serviceName.lastIndexOf('.') + 1);&#10;            Descriptors.ServiceDescriptor serviceDescriptor = fileDesc.findServiceByName(simpleServiceName);&#10;            &#10;            if (serviceDescriptor == null) {&#10;                throw new IllegalArgumentException(&quot;Service not found: &quot; + serviceName);&#10;            }&#10;&#10;            // Get method descriptor&#10;            Descriptors.MethodDescriptor methodDescriptor = serviceDescriptor.findMethodByName(methodName);&#10;&#10;            if (methodDescriptor == null) {&#10;                throw new IllegalArgumentException(&quot;Method not found: &quot; + methodName);&#10;            }&#10;&#10;            // Create gRPC method descriptor&#10;            MethodDescriptor&lt;Message, Message&gt; grpcMethodDescriptor = MethodDescriptor.&lt;Message, Message&gt;newBuilder()&#10;                    .setType(MethodDescriptor.MethodType.UNARY)&#10;                    .setFullMethodName(MethodDescriptor.generateFullMethodName(serviceName, methodName))&#10;                    .setRequestMarshaller(new DynamicMessageMarshaller(methodDescriptor.getInputType()))&#10;                    .setResponseMarshaller(new DynamicMessageMarshaller(methodDescriptor.getOutputType()))&#10;                    .build();&#10;&#10;            // Make the call&#10;            return io.grpc.stub.ClientCalls.blockingUnaryCall(channel, grpcMethodDescriptor, io.grpc.CallOptions.DEFAULT, request);&#10;&#10;        } catch (Exception e) {&#10;            LOGGER.error(&quot;Error making gRPC call&quot;, e);&#10;            throw new RuntimeException(&quot;Failed to make gRPC call&quot;, e);&#10;        }&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/cresterida/gateway/util/DynamicMessageMarshaller.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/cresterida/gateway/util/DynamicMessageMarshaller.java" />
              <option name="originalContent" value="package com.cresterida.gateway.util;&#10;&#10;import com.google.protobuf.Descriptors;&#10;import com.google.protobuf.DynamicMessage;&#10;import com.google.protobuf.Message;&#10;import io.grpc.MethodDescriptor;&#10;import java.io.ByteArrayInputStream;&#10;import java.io.IOException;&#10;import java.io.InputStream;&#10;&#10;public class DynamicMessageMarshaller implements MethodDescriptor.Marshaller&lt;Message&gt; {&#10;    private final Descriptors.Descriptor messageDescriptor;&#10;&#10;    public DynamicMessageMarshaller(Descriptors.Descriptor messageDescriptor) {&#10;        this.messageDescriptor = messageDescriptor;&#10;    }&#10;package com.cresterida.gateway.util;&#10;    @Override&#10;    public Message parse(InputStream inputStream) {&#10;        try {&#10;            return DynamicMessage.newBuilder(messageDescriptor)&#10;                    .mergeFrom(inputStream)&#10;                    .build();&#10;        } catch (IOException e) {&#10;            throw new RuntimeException(&quot;Unable to merge from input stream&quot;, e);&#10;        }&#10;    }&#10;&#10;    @Override&#10;    public InputStream stream(Message message) {&#10;        return new ByteArrayInputStream(message.toByteArray());&#10;    }&#10;}&#10;&#10;import com.google.protobuf.DescriptorProtos;&#10;import com.google.protobuf.Descriptors;&#10;import com.google.protobuf.DynamicMessage;&#10;import com.google.protobuf.Message;&#10;import io.grpc.ManagedChannel;&#10;import io.grpc.ManagedChannelBuilder;&#10;import io.grpc.MethodDescriptor;&#10;import io.grpc.stub.ClientCalls;&#10;import org.slf4j.Logger;&#10;import org.slf4j.LoggerFactory;&#10;&#10;public class ClientCalls {&#10;    private static final Logger LOGGER = LoggerFactory.getLogger(ClientCalls.class);&#10;&#10;    public static Message makeUnaryCall(&#10;            String host,&#10;            int port,&#10;            String serviceName,&#10;            String methodName,&#10;            Message request,&#10;            DescriptorProtos.FileDescriptorProto fileDescriptor) {&#10;        try {&#10;            // Create channel&#10;            ManagedChannel channel = ManagedChannelBuilder.forAddress(host, port)&#10;                    .usePlaintext()&#10;                    .build();&#10;&#10;            // Get service descriptor&#10;            Descriptors.ServiceDescriptor serviceDescriptor = Descriptors.ServiceDescriptor.newBuilder(fileDescriptor)&#10;                    .setFullName(serviceName)&#10;                    .build();&#10;&#10;            // Get method descriptor&#10;            Descriptors.MethodDescriptor methodDescriptor = serviceDescriptor.findMethodByName(methodName);&#10;&#10;            if (methodDescriptor == null) {&#10;                throw new IllegalArgumentException(&quot;Method not found: &quot; + methodName);&#10;            }&#10;&#10;            // Create gRPC method descriptor&#10;            MethodDescriptor&lt;Message, Message&gt; grpcMethodDescriptor = MethodDescriptor.&lt;Message, Message&gt;newBuilder()&#10;                    .setType(MethodDescriptor.MethodType.UNARY)&#10;                    .setFullMethodName(MethodDescriptor.generateFullMethodName(serviceName, methodName))&#10;                    .setRequestMarshaller(new DynamicMessageMarshaller(methodDescriptor.getInputType()))&#10;                    .setResponseMarshaller(new DynamicMessageMarshaller(methodDescriptor.getOutputType()))&#10;                    .build();&#10;&#10;            // Make the call&#10;            return io.grpc.stub.ClientCalls.blockingUnaryCall(channel, grpcMethodDescriptor, io.grpc.CallOptions.DEFAULT, request);&#10;&#10;        } catch (Exception e) {&#10;            LOGGER.error(&quot;Error making gRPC call&quot;, e);&#10;            throw new RuntimeException(&quot;Failed to make gRPC call&quot;, e);&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.cresterida.gateway.util;&#10;&#10;import com.google.protobuf.Descriptors;&#10;import com.google.protobuf.DynamicMessage;&#10;import com.google.protobuf.Message;&#10;import io.grpc.MethodDescriptor;&#10;import java.io.ByteArrayInputStream;&#10;import java.io.IOException;&#10;import java.io.InputStream;&#10;&#10;public class DynamicMessageMarshaller implements MethodDescriptor.Marshaller&lt;Message&gt; {&#10;    private final Descriptors.Descriptor messageDescriptor;&#10;&#10;    public DynamicMessageMarshaller(Descriptors.Descriptor messageDescriptor) {&#10;        this.messageDescriptor = messageDescriptor;&#10;    }&#10;&#10;    @Override&#10;    public Message parse(InputStream inputStream) {&#10;        try {&#10;            return DynamicMessage.newBuilder(messageDescriptor)&#10;                    .mergeFrom(inputStream)&#10;                    .build();&#10;        } catch (IOException e) {&#10;            throw new RuntimeException(&quot;Unable to merge from input stream&quot;, e);&#10;        }&#10;    }&#10;&#10;    @Override&#10;    public InputStream stream(Message message) {&#10;        return new ByteArrayInputStream(message.toByteArray());&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>