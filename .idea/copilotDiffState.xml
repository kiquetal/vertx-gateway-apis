<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/Dockerfile">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Dockerfile" />
              <option name="updatedContent" value="# Build stage&#10;FROM maven:3.9-eclipse-temurin-21 AS builder&#10;WORKDIR /build&#10;# Copy only the POM first to cache dependencies&#10;COPY pom.xml .&#10;RUN mvn dependency:go-offline&#10;&#10;# Copy source and build&#10;COPY src ./src&#10;RUN mvn clean package -DskipTests&#10;&#10;# Run stage&#10;FROM eclipse-temurin:21-jre-jammy&#10;WORKDIR /app&#10;&#10;# Create non-root user for security&#10;RUN addgroup --system --gid 1001 vertx &amp;&amp; \&#10;    adduser --system --uid 1001 --gid 1001 vertx&#10;&#10;# Copy only the fat JAR from builder stage&#10;COPY --from=builder /build/target/*-fat.jar app.jar&#10;RUN chown -R vertx:vertx /app&#10;&#10;# Switch to non-root user&#10;USER vertx&#10;&#10;# Environment variables&#10;ENV LOG_LEVEL=INFO&#10;ENV SHUTDOWN_TIMEOUT_MS=30000&#10;&#10;# Expose the application port&#10;EXPOSE 8080&#10;&#10;# Set the entry point with Java 21 optimizations&#10;ENTRYPOINT [&quot;java&quot;, \&#10;    &quot;--enable-preview&quot;, \&#10;    &quot;--enable-native-access=ALL-UNNAMED&quot;, \&#10;    &quot;-XX:+UseZGC&quot;, \&#10;    &quot;-XX:+ZGenerational&quot;, \&#10;    &quot;-Djdk.virtualThreadScheduler.parallelism=16&quot;, \&#10;    &quot;-jar&quot;, &quot;app.jar&quot;]" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/monitoring/promtail/promtail-config.yml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/monitoring/promtail/promtail-config.yml" />
              <option name="updatedContent" value="server:&#10;  http_listen_port: 9080&#10;  grpc_listen_port: 0&#10;&#10;positions:&#10;  filename: /tmp/positions.yaml&#10;&#10;clients:&#10;  - url: http://loki:3100/loki/api/v1/push&#10;&#10;scrape_configs:&#10;  - job_name: vertx-logs&#10;    pipeline_stages:&#10;      - json:&#10;          expressions:&#10;            ts: timestamp&#10;            level: level&#10;            logger: logger&#10;            thread: thread&#10;            message: message&#10;      - timestamp:&#10;          source: ts&#10;          format: &quot;2006-01-02 15:04:05.000&quot;&#10;      - labels:&#10;          level:&#10;          logger:&#10;          thread:&#10;    static_configs:&#10;      - targets:&#10;          - localhost&#10;        labels:&#10;          job: vertx&#10;          app: gateway&#10;          __path__: /var/log/vertx/application*.log" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/cresterida/gateway/handlers/DynamicGrpcProxyHandler.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/cresterida/gateway/handlers/DynamicGrpcProxyHandler.java" />
              <option name="originalContent" value="package com.cresterida.gateway.handlers;&#10;&#10;import com.cresterida.gateway.model.ServiceDefinition;&#10;import com.cresterida.gateway.model.EndpointDefinition;&#10;import com.cresterida.gateway.model.ServiceInstance;&#10;import io.vertx.core.Handler;&#10;import io.vertx.core.json.JsonObject;&#10;import io.vertx.ext.web.RoutingContext;&#10;import io.grpc.ManagedChannel;&#10;import io.grpc.ManagedChannelBuilder;&#10;import com.google.protobuf.DynamicMessage;&#10;import com.google.protobuf.DescriptorProtos;&#10;import com.google.protobuf.Descriptors;&#10;import com.google.protobuf.TextFormat;&#10;import org.apache.logging.log4j.LogManager;&#10;import org.apache.logging.log4j.Logger;&#10;&#10;import java.util.List;&#10;import java.util.Map;&#10;&#10;public class DynamicGrpcProxyHandler implements Handler&lt;RoutingContext&gt; {&#10;    private static final Logger LOGGER = LogManager.getLogger(DynamicGrpcProxyHandler.class);&#10;&#10;    @Override&#10;    public void handle(RoutingContext ctx) {&#10;        ServiceDefinition sd = ctx.get(&quot;service&quot;);&#10;        if (sd == null) {&#10;            ctx.next();&#10;            return;&#10;        }&#10;&#10;        // Get the first instance (we'll implement load balancing later)&#10;        List&lt;ServiceInstance&gt; instances = sd.getInstances();&#10;        if (instances.isEmpty()) {&#10;            fail(ctx, 503, &quot;No service instances available&quot;);&#10;            return;&#10;        }&#10;        ServiceInstance instance = instances.get(0);&#10;        String host = instance.getHost();&#10;        int port = instance.getPort();&#10;&#10;        // Create channel&#10;        ManagedChannel channel = ManagedChannelBuilder&#10;            .forAddress(host, port)&#10;            .usePlaintext()&#10;            .build();&#10;&#10;        try {&#10;            // Extract method name from path&#10;            String path = ctx.request().path();&#10;            String methodName = path.substring(path.lastIndexOf('/') + 1);&#10;&#10;            // Find matching endpoint&#10;            Map&lt;String, EndpointDefinition&gt; endpoints = sd.getEndpoints();&#10;            EndpointDefinition endpoint = endpoints.get(methodName);&#10;            if (endpoint == null) {&#10;                fail(ctx, 404, &quot;Endpoint not found: &quot; + methodName);&#10;                return;&#10;            }&#10;&#10;            // Create proto parser and parse the definition&#10;            DescriptorProtos.FileDescriptorSet.Builder fileDescriptorSet = DescriptorProtos.FileDescriptorSet.newBuilder();&#10;&#10;            try {&#10;                DescriptorProtos.FileDescriptorProto.Builder fileBuilder = DescriptorProtos.FileDescriptorProto.newBuilder()&#10;                    .setName(&quot;service.proto&quot;)&#10;                    .setSyntax(&quot;proto3&quot;)&#10;                    .setPackage(sd.getPackageName());&#10;&#10;                // Parse the proto definition text&#10;                TextFormat.merge(sd.getProtoDefinition(), fileBuilder);&#10;                fileDescriptorSet.addFile(fileBuilder.build());&#10;&#10;                // Build the file descriptor&#10;                Descriptors.FileDescriptor fileDescriptor = Descriptors.FileDescriptor.buildFrom(&#10;                    fileDescriptorSet.getFile(0),&#10;                    new Descriptors.FileDescriptor[0]&#10;                );&#10;&#10;            // Get service descriptor using the service name and package from ServiceDefinition&#10;            String fullServiceName = sd.getPackageName() + &quot;.&quot; + sd.getName();&#10;            Descriptors.ServiceDescriptor serviceDescriptor = null;&#10;            for (Descriptors.ServiceDescriptor svc : fileDescriptor.getServices()) {&#10;                if (svc.getFullName().equals(fullServiceName)) {&#10;                    serviceDescriptor = svc;&#10;                    break;&#10;                }&#10;            }&#10;            if (serviceDescriptor == null) {&#10;                throw new IllegalStateException(&quot;Service '&quot; + fullServiceName + &quot;' not found in proto definition&quot;);&#10;            }&#10;&#10;            // Get method descriptor from endpoint&#10;            Descriptors.MethodDescriptor methodDescriptor = serviceDescriptor.findMethodByName(endpoint.getMethodName());&#10;            if (methodDescriptor == null) {&#10;                throw new IllegalStateException(&quot;Method '&quot; + endpoint.getMethodName() + &quot;' not found in service definition&quot;);&#10;            }&#10;&#10;            // Get message descriptors&#10;            Descriptors.Descriptor inputDescriptor = methodDescriptor.getInputType();&#10;            Descriptors.Descriptor outputDescriptor = methodDescriptor.getOutputType();&#10;&#10;            // Build request message&#10;            JsonObject requestBody = ctx.body().asJsonObject();&#10;            DynamicMessage.Builder requestBuilder = DynamicMessage.newBuilder(inputDescriptor);&#10;&#10;            // Set the name field directly from the request body&#10;            Descriptors.FieldDescriptor nameField = inputDescriptor.findFieldByName(&quot;name&quot;);&#10;            if (nameField != null) {&#10;                requestBuilder.setField(nameField, requestBody.getString(&quot;name&quot;));&#10;            }&#10;&#10;            // Create method descriptor for gRPC call using the service's full name&#10;            io.grpc.MethodDescriptor&lt;DynamicMessage, DynamicMessage&gt; grpcMethod =&#10;                io.grpc.MethodDescriptor.&lt;DynamicMessage, DynamicMessage&gt;newBuilder()&#10;                    .setType(io.grpc.MethodDescriptor.MethodType.UNARY)&#10;                    .setFullMethodName(io.grpc.MethodDescriptor.generateFullMethodName(&#10;                        fullServiceName, endpoint.getMethodName()))&#10;                    .setRequestMarshaller(new DynamicMessageMarshaller(inputDescriptor))&#10;                    .setResponseMarshaller(new DynamicMessageMarshaller(outputDescriptor))&#10;                    .build();&#10;&#10;            // Make the gRPC call&#10;            DynamicMessage request = requestBuilder.build();&#10;            DynamicMessage response = io.grpc.stub.ClientCalls.blockingUnaryCall(&#10;                channel.newCall(grpcMethod, io.grpc.CallOptions.DEFAULT),&#10;                request&#10;            );&#10;&#10;            // Extract response message field&#10;            JsonObject jsonResponse = new JsonObject();&#10;            Descriptors.FieldDescriptor messageField = outputDescriptor.findFieldByName(&quot;message&quot;);&#10;            if (messageField != null) {&#10;                Object value = response.getField(messageField);&#10;                jsonResponse.put(&quot;message&quot;, value != null ? value.toString() : &quot;&quot;);&#10;            }&#10;&#10;            ctx.response()&#10;                .putHeader(&quot;Content-Type&quot;, &quot;application/json&quot;)&#10;                .end(jsonResponse.encode());&#10;&#10;        } catch (Exception e) {&#10;            LOGGER.error(&quot;Error processing gRPC request&quot;, e);&#10;            fail(ctx, 500, &quot;Error processing gRPC request: &quot; + e.getMessage());&#10;        } finally {&#10;            channel.shutdown();&#10;        }&#10;    }&#10;&#10;    private void fail(RoutingContext ctx, int statusCode, String message) {&#10;        ctx.response()&#10;            .setStatusCode(statusCode)&#10;            .putHeader(&quot;Content-Type&quot;, &quot;application/json&quot;)&#10;            .end(new JsonObject()&#10;                .put(&quot;error&quot;, message)&#10;                .put(&quot;status&quot;, statusCode)&#10;                .put(&quot;path&quot;, ctx.request().path())&#10;                .encode());&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.cresterida.gateway.handlers;&#10;&#10;import com.cresterida.gateway.model.ServiceDefinition;&#10;import com.cresterida.gateway.model.EndpointDefinition;&#10;import com.cresterida.gateway.model.ServiceInstance;&#10;import io.vertx.core.Handler;&#10;import io.vertx.core.json.JsonObject;&#10;import io.vertx.ext.web.RoutingContext;&#10;import io.grpc.ManagedChannel;&#10;import io.grpc.ManagedChannelBuilder;&#10;import com.google.protobuf.DynamicMessage;&#10;import com.google.protobuf.DescriptorProtos;&#10;import com.google.protobuf.Descriptors;&#10;import com.google.protobuf.TextFormat;&#10;import org.apache.logging.log4j.LogManager;&#10;import org.apache.logging.log4j.Logger;&#10;&#10;import java.util.List;&#10;import java.util.Map;&#10;&#10;public class DynamicGrpcProxyHandler implements Handler&lt;RoutingContext&gt; {&#10;    private static final Logger LOGGER = LogManager.getLogger(DynamicGrpcProxyHandler.class);&#10;&#10;    private void handleError(RoutingContext ctx, int statusCode, String message) {&#10;        ctx.response()&#10;            .setStatusCode(statusCode)&#10;            .putHeader(&quot;Content-Type&quot;, &quot;application/json&quot;)&#10;            .end(new JsonObject()&#10;                .put(&quot;error&quot;, message)&#10;                .put(&quot;status&quot;, statusCode)&#10;                .put(&quot;path&quot;, ctx.request().path())&#10;                .encode());&#10;    }&#10;&#10;    @Override&#10;    public void handle(RoutingContext ctx) {&#10;        ServiceDefinition sd = ctx.get(&quot;service&quot;);&#10;        if (sd == null) {&#10;            ctx.next();&#10;            return;&#10;        }&#10;&#10;        // Get the first instance (we'll implement load balancing later)&#10;        List&lt;ServiceInstance&gt; instances = sd.getInstances();&#10;        if (instances.isEmpty()) {&#10;            handleError(ctx, 503, &quot;No service instances available&quot;);&#10;            return;&#10;        }&#10;        ServiceInstance instance = instances.get(0);&#10;        String host = instance.getHost();&#10;        int port = instance.getPort();&#10;&#10;        // Create channel&#10;        ManagedChannel channel = ManagedChannelBuilder&#10;            .forAddress(host, port)&#10;            .usePlaintext()&#10;            .build();&#10;&#10;        try {&#10;            // Extract method name from path&#10;            String path = ctx.request().path();&#10;            String methodName = path.substring(path.lastIndexOf('/') + 1);&#10;&#10;            // Find matching endpoint&#10;            Map&lt;String, EndpointDefinition&gt; endpoints = sd.getEndpoints();&#10;            EndpointDefinition endpoint = endpoints.get(methodName);&#10;            if (endpoint == null) {&#10;                handleError(ctx, 404, &quot;Endpoint not found: &quot; + methodName);&#10;                return;&#10;            }&#10;&#10;            // Create proto parser and parse the definition&#10;            DescriptorProtos.FileDescriptorSet.Builder fileDescriptorSet = DescriptorProtos.FileDescriptorSet.newBuilder();&#10;&#10;            try {&#10;                DescriptorProtos.FileDescriptorProto.Builder fileBuilder = DescriptorProtos.FileDescriptorProto.newBuilder()&#10;                    .setName(&quot;service.proto&quot;)&#10;                    .setSyntax(&quot;proto3&quot;)&#10;                    .setPackage(sd.getPackageName());&#10;&#10;                // Parse the proto definition text&#10;                TextFormat.merge(sd.getProtoDefinition(), fileBuilder);&#10;                fileDescriptorSet.addFile(fileBuilder.build());&#10;&#10;                // Build the file descriptor&#10;                Descriptors.FileDescriptor fileDescriptor = Descriptors.FileDescriptor.buildFrom(&#10;                    fileDescriptorSet.getFile(0),&#10;                    new Descriptors.FileDescriptor[0]&#10;                );&#10;&#10;                // Get service descriptor using the service name and package from ServiceDefinition&#10;                String fullServiceName = sd.getPackageName() + &quot;.&quot; + sd.getName();&#10;                Descriptors.ServiceDescriptor serviceDescriptor = null;&#10;                for (Descriptors.ServiceDescriptor svc : fileDescriptor.getServices()) {&#10;                    if (svc.getFullName().equals(fullServiceName)) {&#10;                        serviceDescriptor = svc;&#10;                        break;&#10;                    }&#10;                }&#10;                if (serviceDescriptor == null) {&#10;                    handleError(ctx, 500, &quot;Service '&quot; + fullServiceName + &quot;' not found in proto definition&quot;);&#10;                    return;&#10;                }&#10;&#10;                // Get method descriptor from endpoint&#10;                Descriptors.MethodDescriptor methodDescriptor = serviceDescriptor.findMethodByName(endpoint.getMethodName());&#10;                if (methodDescriptor == null) {&#10;                    handleError(ctx, 500, &quot;Method '&quot; + endpoint.getMethodName() + &quot;' not found in service definition&quot;);&#10;                    return;&#10;                }&#10;&#10;                // Get message descriptors&#10;                Descriptors.Descriptor inputDescriptor = methodDescriptor.getInputType();&#10;                Descriptors.Descriptor outputDescriptor = methodDescriptor.getOutputType();&#10;&#10;                // Build request message&#10;                JsonObject requestBody = ctx.body().asJsonObject();&#10;                DynamicMessage.Builder requestBuilder = DynamicMessage.newBuilder(inputDescriptor);&#10;&#10;                // Set the name field directly from the request body&#10;                Descriptors.FieldDescriptor nameField = inputDescriptor.findFieldByName(&quot;name&quot;);&#10;                if (nameField != null) {&#10;                    requestBuilder.setField(nameField, requestBody.getString(&quot;name&quot;));&#10;                }&#10;&#10;                // Create method descriptor for gRPC call using the service's full name&#10;                io.grpc.MethodDescriptor&lt;DynamicMessage, DynamicMessage&gt; grpcMethod =&#10;                    io.grpc.MethodDescriptor.&lt;DynamicMessage, DynamicMessage&gt;newBuilder()&#10;                        .setType(io.grpc.MethodDescriptor.MethodType.UNARY)&#10;                        .setFullMethodName(io.grpc.MethodDescriptor.generateFullMethodName(&#10;                            fullServiceName, endpoint.getMethodName()))&#10;                        .setRequestMarshaller(new DynamicMessageMarshaller(inputDescriptor))&#10;                        .setResponseMarshaller(new DynamicMessageMarshaller(outputDescriptor))&#10;                        .build();&#10;&#10;                // Make the gRPC call&#10;                DynamicMessage request = requestBuilder.build();&#10;                DynamicMessage response = io.grpc.stub.ClientCalls.blockingUnaryCall(&#10;                    channel.newCall(grpcMethod, io.grpc.CallOptions.DEFAULT),&#10;                    request&#10;                );&#10;&#10;                // Extract response message field&#10;                JsonObject jsonResponse = new JsonObject();&#10;                Descriptors.FieldDescriptor messageField = outputDescriptor.findFieldByName(&quot;message&quot;);&#10;                if (messageField != null) {&#10;                    Object value = response.getField(messageField);&#10;                    jsonResponse.put(&quot;message&quot;, value != null ? value.toString() : &quot;&quot;);&#10;                }&#10;&#10;                ctx.response()&#10;                    .putHeader(&quot;Content-Type&quot;, &quot;application/json&quot;)&#10;                    .end(jsonResponse.encode());&#10;&#10;            } catch (Exception e) {&#10;                LOGGER.error(&quot;Error processing gRPC request&quot;, e);&#10;                handleError(ctx, 500, &quot;Error processing gRPC request: &quot; + e.getMessage());&#10;            } finally {&#10;                channel.shutdown();&#10;            }&#10;    }&#10;&#10;    private void handleError(RoutingContext ctx, int statusCode, String message) {&#10;        ctx.response()&#10;            .setStatusCode(statusCode)&#10;            .putHeader(&quot;Content-Type&quot;, &quot;application/json&quot;)&#10;            .end(new JsonObject()&#10;                .put(&quot;error&quot;, message)&#10;                .put(&quot;status&quot;, statusCode)&#10;                .put(&quot;path&quot;, ctx.request().path())&#10;                .encode());&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/cresterida/gateway/model/ServiceDefinition.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/cresterida/gateway/model/ServiceDefinition.java" />
              <option name="originalContent" value="package com.cresterida.gateway.model;&#10;&#10;import io.vertx.core.json.JsonObject;&#10;import io.vertx.core.json.JsonArray;&#10;import java.util.List;&#10;import java.util.ArrayList;&#10;import java.util.Map;&#10;import java.util.HashMap;&#10;import java.util.Collections;&#10;import java.net.URI;&#10;&#10;public class ServiceDefinition {&#10;    private final String id;&#10;    private final String name;&#10;    private final String packageName;&#10;    private final String version;&#10;    private final String protoDefinition;&#10;    private final List&lt;ServiceInstance&gt; instances;&#10;    private final Map&lt;String, EndpointDefinition&gt; endpoints;&#10;    private final int burstCapacity;&#10;    private final int rateLimitPerSecond;&#10;    private final Map&lt;String, JsonFieldMapping&gt; fieldMappings;&#10;    private final String pathPrefix;&#10;    private final String upstreamBaseUrl;&#10;    private final boolean stripPrefix;&#10;&#10;    private ServiceDefinition(Builder builder) {&#10;        this.id = builder.id;&#10;        this.name = builder.name;&#10;        this.packageName = builder.packageName;&#10;        this.version = builder.version;&#10;        this.protoDefinition = builder.protoDefinition;&#10;        this.instances = new ArrayList&lt;&gt;(builder.instances);&#10;        this.endpoints = new HashMap&lt;&gt;(builder.endpoints);&#10;        this.burstCapacity = builder.burstCapacity;&#10;        this.rateLimitPerSecond = builder.rateLimitPerSecond;&#10;        this.fieldMappings = new HashMap&lt;&gt;(builder.fieldMappings);&#10;        this.pathPrefix = builder.pathPrefix;&#10;        this.upstreamBaseUrl = builder.upstreamBaseUrl;&#10;        this.stripPrefix = builder.stripPrefix;&#10;    }&#10;&#10;    public static ServiceDefinition fromJson(JsonObject json) {&#10;        if (json == null) {&#10;            throw new IllegalArgumentException(&quot;JSON cannot be null&quot;);&#10;        }&#10;&#10;        Builder builder = new Builder()&#10;            .setId(json.getString(&quot;id&quot;))&#10;            .setName(json.getString(&quot;name&quot;))&#10;            .setPackage(json.getString(&quot;packageName&quot;))&#10;            .setVersion(json.getString(&quot;version&quot;))&#10;            .setProtoDefinition(json.getString(&quot;protoDefinition&quot;))&#10;            .setBurstCapacity(json.getInteger(&quot;burstCapacity&quot;, 100))&#10;            .setRateLimitPerSecond(json.getInteger(&quot;rateLimitPerSecond&quot;, 10))&#10;            .setPathPrefix(json.getString(&quot;pathPrefix&quot;, &quot;/&quot;))&#10;            .setUpstreamBaseUrl(json.getString(&quot;upstreamBaseUrl&quot;))&#10;            .setStripPrefix(json.getBoolean(&quot;stripPrefix&quot;, false));&#10;&#10;        if (json.containsKey(&quot;instances&quot;)) {&#10;            JsonArray instances = json.getJsonArray(&quot;instances&quot;);&#10;            if (instances != null) {&#10;                instances.forEach(inst -&gt; {&#10;                    if (inst instanceof JsonObject) {&#10;                        JsonObject instObj = (JsonObject) inst;&#10;                        builder.addInstance(new ServiceInstance(&#10;                            instObj.getString(&quot;host&quot;),&#10;                            instObj.getInteger(&quot;port&quot;)&#10;                        ));&#10;                    }&#10;                });&#10;            }&#10;        }&#10;&#10;        // Parse endpoints if provided and add to builder&#10;        if (json.containsKey(&quot;endpoints&quot;)) {&#10;            JsonArray eps = json.getJsonArray(&quot;endpoints&quot;);&#10;            if (eps != null) {&#10;                eps.forEach(e -&gt; {&#10;                    if (e instanceof JsonObject) {&#10;                        EndpointDefinition ed = EndpointDefinition.fromJson((JsonObject) e);&#10;                        if (ed.getName() != null) {&#10;                            builder.addEndpoint(ed);&#10;                        }&#10;                    }&#10;                });&#10;            }&#10;        }&#10;&#10;        return builder.build();&#10;    }&#10;&#10;    public String getId() {&#10;        return id;&#10;    }&#10;&#10;    public String getName() {&#10;        return name;&#10;    }&#10;&#10;    public String getPackageName() {&#10;        return packageName;&#10;    }&#10;&#10;    public String getVersion() {&#10;        return version;&#10;    }&#10;&#10;    public String getProtoDefinition() {&#10;        return protoDefinition;&#10;    }&#10;&#10;    public List&lt;ServiceInstance&gt; getInstances() {&#10;        return Collections.unmodifiableList(instances);&#10;    }&#10;&#10;    public Map&lt;String, EndpointDefinition&gt; getEndpoints() {&#10;        return Collections.unmodifiableMap(endpoints);&#10;    }&#10;&#10;    public int getBurstCapacity() {&#10;        return burstCapacity;&#10;    }&#10;&#10;    public int getRateLimitPerSecond() {&#10;        return rateLimitPerSecond;&#10;    }&#10;&#10;    public String getPathPrefix() {&#10;        return pathPrefix;&#10;    }&#10;&#10;    public String getUpstreamBaseUrl() {&#10;        return upstreamBaseUrl;&#10;    }&#10;&#10;    public boolean isStripPrefix() {&#10;        return stripPrefix;&#10;    }&#10;&#10;    public JsonObject toJson() {&#10;        JsonObject json = new JsonObject()&#10;            .put(&quot;id&quot;, id)&#10;            .put(&quot;name&quot;, name)&#10;            .put(&quot;packageName&quot;, packageName)&#10;            .put(&quot;version&quot;, version)&#10;            .put(&quot;protoDefinition&quot;, protoDefinition)&#10;            .put(&quot;burstCapacity&quot;, burstCapacity)&#10;            .put(&quot;rateLimitPerSecond&quot;, rateLimitPerSecond)&#10;            .put(&quot;pathPrefix&quot;, pathPrefix)&#10;            .put(&quot;upstreamBaseUrl&quot;, upstreamBaseUrl)&#10;            .put(&quot;stripPrefix&quot;, stripPrefix);&#10;&#10;        if (!instances.isEmpty()) {&#10;            JsonArray instancesArray = new JsonArray();&#10;            instances.forEach(instance -&gt; {&#10;                instancesArray.add(instance.toJson());&#10;            });&#10;            json.put(&quot;instances&quot;, instancesArray);&#10;        }&#10;&#10;        // Serialize endpoints if present&#10;        if (!endpoints.isEmpty()) {&#10;            JsonArray eps = new JsonArray();&#10;            endpoints.values().forEach(ed -&gt; eps.add(ed.toJson()));&#10;            json.put(&quot;endpoints&quot;, eps);&#10;        }&#10;&#10;        return json;&#10;    }&#10;&#10;    public static class Builder {&#10;        private String id;&#10;        private String name;&#10;        private String packageName;&#10;        private String version;&#10;        private String protoDefinition;&#10;        private List&lt;ServiceInstance&gt; instances = new ArrayList&lt;&gt;();&#10;        private Map&lt;String, EndpointDefinition&gt; endpoints = new HashMap&lt;&gt;();&#10;        private int burstCapacity = 100;&#10;        private int rateLimitPerSecond = 10;&#10;        private Map&lt;String, JsonFieldMapping&gt; fieldMappings = new HashMap&lt;&gt;();&#10;        private String pathPrefix = &quot;/&quot;;&#10;        private String upstreamBaseUrl;&#10;        private boolean stripPrefix;&#10;&#10;        public Builder setId(String id) { this.id = id; return this; }&#10;        public Builder setName(String name) { this.name = name; return this; }&#10;        public Builder setPackage(String packageName) { this.packageName = packageName; return this; }&#10;        public Builder setVersion(String version) { this.version = version; return this; }&#10;        public Builder setProtoDefinition(String protoDefinition) { this.protoDefinition = protoDefinition; return this; }&#10;        public Builder addInstance(ServiceInstance instance) { this.instances.add(instance); return this; }&#10;        public Builder addEndpoint(EndpointDefinition endpoint) { this.endpoints.put(endpoint.getName(), endpoint); return this; }&#10;        public Builder setBurstCapacity(int burstCapacity) { this.burstCapacity = burstCapacity; return this; }&#10;        public Builder setRateLimitPerSecond(int rateLimitPerSecond) { this.rateLimitPerSecond = rateLimitPerSecond; return this; }&#10;        public Builder setPathPrefix(String pathPrefix) { this.pathPrefix = pathPrefix; return this; }&#10;        public Builder setUpstreamBaseUrl(String upstreamBaseUrl) { this.upstreamBaseUrl = upstreamBaseUrl; return this; }&#10;        public Builder setStripPrefix(boolean stripPrefix) { this.stripPrefix = stripPrefix; return this; }&#10;&#10;        public ServiceDefinition build() {&#10;            return new ServiceDefinition(this);&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.cresterida.gateway.model;&#10;&#10;import io.vertx.core.json.JsonObject;&#10;import io.vertx.core.json.JsonArray;&#10;import java.util.List;&#10;import java.util.ArrayList;&#10;import java.util.Map;&#10;import java.util.HashMap;&#10;import java.util.Collections;&#10;import java.net.URI;&#10;&#10;public class ServiceDefinition {&#10;    private final String id;&#10;    private final String name;&#10;    private final String packageName;&#10;    private final String version;&#10;    private final String protoDefinition;&#10;    private final List&lt;ServiceInstance&gt; instances;&#10;    private final Map&lt;String, EndpointDefinition&gt; endpoints;&#10;    private final int burstCapacity;&#10;    private final int rateLimitPerSecond;&#10;    private final Map&lt;String, JsonFieldMapping&gt; fieldMappings;&#10;    private final String pathPrefix;&#10;    private final String upstreamBaseUrl;&#10;    private final boolean stripPrefix;&#10;&#10;    private ServiceDefinition(Builder builder) {&#10;        this.id = builder.id;&#10;        this.name = builder.name;&#10;        this.packageName = builder.packageName;&#10;        this.version = builder.version;&#10;        this.protoDefinition = builder.protoDefinition;&#10;        this.instances = new ArrayList&lt;&gt;(builder.instances);&#10;        this.endpoints = new HashMap&lt;&gt;(builder.endpoints);&#10;        this.burstCapacity = builder.burstCapacity;&#10;        this.rateLimitPerSecond = builder.rateLimitPerSecond;&#10;        this.fieldMappings = new HashMap&lt;&gt;(builder.fieldMappings);&#10;        this.pathPrefix = builder.pathPrefix;&#10;        this.upstreamBaseUrl = builder.upstreamBaseUrl;&#10;        this.stripPrefix = builder.stripPrefix;&#10;    }&#10;&#10;    public static ServiceDefinition fromJson(JsonObject json) {&#10;        if (json == null) {&#10;            throw new IllegalArgumentException(&quot;JSON cannot be null&quot;);&#10;        }&#10;&#10;        Builder builder = new Builder()&#10;            .setId(json.getString(&quot;id&quot;))&#10;            .setName(json.getString(&quot;name&quot;))&#10;            .setPackage(json.getString(&quot;packageName&quot;))&#10;            .setVersion(json.getString(&quot;version&quot;))&#10;            .setProtoDefinition(json.getString(&quot;protoDefinition&quot;))&#10;            .setBurstCapacity(json.getInteger(&quot;burstCapacity&quot;, 100))&#10;            .setRateLimitPerSecond(json.getInteger(&quot;rateLimitPerSecond&quot;, 10))&#10;            .setPathPrefix(json.getString(&quot;pathPrefix&quot;, &quot;/&quot;))&#10;            .setUpstreamBaseUrl(json.getString(&quot;upstreamBaseUrl&quot;))&#10;            .setStripPrefix(json.getBoolean(&quot;stripPrefix&quot;, false));&#10;&#10;        if (json.containsKey(&quot;instances&quot;)) {&#10;            JsonArray instances = json.getJsonArray(&quot;instances&quot;);&#10;            if (instances != null) {&#10;                instances.forEach(inst -&gt; {&#10;                    if (inst instanceof JsonObject) {&#10;                        JsonObject instObj = (JsonObject) inst;&#10;                        builder.addInstance(new ServiceInstance(&#10;                            instObj.getString(&quot;host&quot;),&#10;                            instObj.getInteger(&quot;port&quot;)&#10;                        ));&#10;                    }&#10;                });&#10;            }&#10;        }&#10;&#10;        // Parse endpoints if provided and add to builder&#10;        if (json.containsKey(&quot;endpoints&quot;)) {&#10;            JsonArray eps = json.getJsonArray(&quot;endpoints&quot;);&#10;            if (eps != null) {&#10;                eps.forEach(e -&gt; {&#10;                    if (e instanceof JsonObject) {&#10;                        EndpointDefinition ed = EndpointDefinition.fromJson((JsonObject) e);&#10;                        if (ed.getName() != null) {&#10;                            builder.addEndpoint(ed);&#10;                        }&#10;                    }&#10;                });&#10;            }&#10;        }&#10;&#10;        return builder.build();&#10;    }&#10;&#10;    // Getters with proper return types and immutable collections&#10;    public String getId() { return id; }&#10;    public String getName() { return name; }&#10;    public String getPackageName() { return packageName; }&#10;    public String getVersion() { return version; }&#10;    public String getProtoDefinition() { return protoDefinition; }&#10;    public List&lt;ServiceInstance&gt; getInstances() { return Collections.unmodifiableList(instances); }&#10;    public Map&lt;String, EndpointDefinition&gt; getEndpoints() { return Collections.unmodifiableMap(endpoints); }&#10;    public int getBurstCapacity() { return burstCapacity; }&#10;    public int getRateLimitPerSecond() { return rateLimitPerSecond; }&#10;    public String getPathPrefix() { return pathPrefix; }&#10;    public String getUpstreamBaseUrl() { return upstreamBaseUrl; }&#10;    public boolean isStripPrefix() { return stripPrefix; }&#10;&#10;    public JsonObject toJson() {&#10;        JsonObject json = new JsonObject()&#10;            .put(&quot;id&quot;, id)&#10;            .put(&quot;name&quot;, name)&#10;            .put(&quot;packageName&quot;, packageName)&#10;            .put(&quot;version&quot;, version)&#10;            .put(&quot;protoDefinition&quot;, protoDefinition)&#10;            .put(&quot;burstCapacity&quot;, burstCapacity)&#10;            .put(&quot;rateLimitPerSecond&quot;, rateLimitPerSecond)&#10;            .put(&quot;pathPrefix&quot;, pathPrefix)&#10;            .put(&quot;upstreamBaseUrl&quot;, upstreamBaseUrl)&#10;            .put(&quot;stripPrefix&quot;, stripPrefix);&#10;&#10;        if (!instances.isEmpty()) {&#10;            JsonArray instancesArray = new JsonArray();&#10;            instances.forEach(instance -&gt; {&#10;                instancesArray.add(instance.toJson());&#10;            });&#10;            json.put(&quot;instances&quot;, instancesArray);&#10;        }&#10;&#10;        // Serialize endpoints if present&#10;        if (!endpoints.isEmpty()) {&#10;            JsonArray eps = new JsonArray();&#10;            endpoints.values().forEach(ed -&gt; eps.add(ed.toJson()));&#10;            json.put(&quot;endpoints&quot;, eps);&#10;        }&#10;&#10;        return json;&#10;    }&#10;&#10;    public static class Builder {&#10;        private String id;&#10;        private String name;&#10;        private String packageName;&#10;        private String version;&#10;        private String protoDefinition;&#10;        private List&lt;ServiceInstance&gt; instances = new ArrayList&lt;&gt;();&#10;        private Map&lt;String, EndpointDefinition&gt; endpoints = new HashMap&lt;&gt;();&#10;        private int burstCapacity = 100;&#10;        private int rateLimitPerSecond = 10;&#10;        private Map&lt;String, JsonFieldMapping&gt; fieldMappings = new HashMap&lt;&gt;();&#10;        private String pathPrefix = &quot;/&quot;;&#10;        private String upstreamBaseUrl;&#10;        private boolean stripPrefix;&#10;&#10;        public Builder setId(String id) { this.id = id; return this; }&#10;        public Builder setName(String name) { this.name = name; return this; }&#10;        public Builder setPackage(String packageName) { this.packageName = packageName; return this; }&#10;        public Builder setVersion(String version) { this.version = version; return this; }&#10;        public Builder setProtoDefinition(String protoDefinition) { this.protoDefinition = protoDefinition; return this; }&#10;        public Builder addInstance(ServiceInstance instance) { this.instances.add(instance); return this; }&#10;        public Builder addEndpoint(EndpointDefinition endpoint) { this.endpoints.put(endpoint.getName(), endpoint); return this; }&#10;        public Builder setBurstCapacity(int burstCapacity) { this.burstCapacity = burstCapacity; return this; }&#10;        public Builder setRateLimitPerSecond(int rateLimitPerSecond) { this.rateLimitPerSecond = rateLimitPerSecond; return this; }&#10;        public Builder setPathPrefix(String pathPrefix) { this.pathPrefix = pathPrefix; return this; }&#10;        public Builder setUpstreamBaseUrl(String upstreamBaseUrl) { this.upstreamBaseUrl = upstreamBaseUrl; return this; }&#10;        public Builder setStripPrefix(boolean stripPrefix) { this.stripPrefix = stripPrefix; return this; }&#10;&#10;        public ServiceDefinition build() {&#10;            return new ServiceDefinition(this);&#10;        }&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/resources/create-service.http">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/resources/create-service.http" />
              <option name="originalContent" value="POST http://localhost:8080/admin/services&#10;Content-Type: application/json&#10;&#10;{&#10;  &quot;id&quot;: &quot;greeter-service&quot;,&#10;  &quot;name&quot;: &quot;Greeter&quot;,&#10;  &quot;packageName&quot;: &quot;helloworld&quot;,&#10;  &quot;version&quot;: &quot;1.0&quot;,&#10;  &quot;protoDefinition&quot;: &quot;CgpzZXJ2aWNlLnByb3RvEgpoZWxsb3dvcmxkIjgKCkhlbGxvUmVwbHkSGwoHbWVzc2FnZRgBIAEoCVIHbWVzc2FnZSIiCgxIZWxsb1JlcXVlc3QSEgoEbmFtZRgBIAEoCVIEbmFtZTJKCgdHcmVldGVyEj8KCFNheUhlbGxvEhguaGVsbG93b3JsZC5IZWxsb1JlcXVlc3QaFi5oZWxsb3dvcmxkLkhlbGxvUmVwbHkiAGIGcHJvdG8z&quot;,&#10;  &quot;pathPrefix&quot;: &quot;/api/greeter&quot;,&#10;  &quot;upstreamBaseUrl&quot;: &quot;dns:///localhost:50051&quot;,&#10;  &quot;instances&quot;: [&#10;    {&#10;      &quot;host&quot;: &quot;localhost&quot;,&#10;      &quot;port&quot;: 50051&#10;    }&#10;  ],&#10;  &quot;burstCapacity&quot;: 100,&#10;  &quot;rateLimitPerSecond&quot;: 10,&#10;  &quot;endpoints&quot;: [&#10;    {&#10;      &quot;name&quot;: &quot;sayHello&quot;,&#10;      &quot;methodName&quot;: &quot;SayHello&quot;,&#10;      &quot;inputMessage&quot;: &quot;HelloRequest&quot;,&#10;      &quot;outputMessage&quot;: &quot;HelloReply&quot;,&#10;      &quot;inputMapping&quot;: {&#10;        &quot;name&quot;: &quot;$.name&quot;&#10;      },&#10;      &quot;outputMapping&quot;: {&#10;        &quot;message&quot;: &quot;$.message&quot;&#10;      }&#10;    }&#10;  ]&#10;}&#10;" />
              <option name="updatedContent" value="POST http://localhost:8080/admin/services&#10;Content-Type: application/json&#10;&#10;{&#10;  &quot;id&quot;: &quot;greeter-service&quot;,&#10;  &quot;name&quot;: &quot;Greeter&quot;,&#10;  &quot;packageName&quot;: &quot;helloworld&quot;,&#10;  &quot;version&quot;: &quot;1.0&quot;,&#10;  &quot;protoDefinition&quot;: &quot;syntax = \&quot;proto3\&quot;;\n\npackage helloworld;\n\nservice Greeter {\n  rpc SayHello (HelloRequest) returns (HelloReply) {}\n}\n\nmessage HelloRequest {\n  string name = 1;\n}\n\nmessage HelloReply {\n  string message = 1;\n}&quot;,&#10;  &quot;pathPrefix&quot;: &quot;/api/greeter&quot;,&#10;  &quot;upstreamBaseUrl&quot;: &quot;dns:///localhost:50051&quot;,&#10;  &quot;instances&quot;: [&#10;    {&#10;      &quot;host&quot;: &quot;localhost&quot;,&#10;      &quot;port&quot;: 50051&#10;    }&#10;  ],&#10;  &quot;burstCapacity&quot;: 100,&#10;  &quot;rateLimitPerSecond&quot;: 10,&#10;  &quot;endpoints&quot;: [&#10;    {&#10;      &quot;name&quot;: &quot;sayHello&quot;,&#10;      &quot;methodName&quot;: &quot;SayHello&quot;,&#10;      &quot;inputMessage&quot;: &quot;HelloRequest&quot;,&#10;      &quot;outputMessage&quot;: &quot;HelloReply&quot;,&#10;      &quot;inputMapping&quot;: {&#10;        &quot;name&quot;: &quot;$.name&quot;&#10;      },&#10;      &quot;outputMapping&quot;: {&#10;        &quot;message&quot;: &quot;$.message&quot;&#10;      }&#10;    }&#10;  ]&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>