<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/Dockerfile">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Dockerfile" />
              <option name="updatedContent" value="# Build stage&#10;FROM maven:3.9-eclipse-temurin-21 AS builder&#10;WORKDIR /build&#10;# Copy only the POM first to cache dependencies&#10;COPY pom.xml .&#10;RUN mvn dependency:go-offline&#10;&#10;# Copy source and build&#10;COPY src ./src&#10;RUN mvn clean package -DskipTests&#10;&#10;# Run stage&#10;FROM eclipse-temurin:21-jre-jammy&#10;WORKDIR /app&#10;&#10;# Create non-root user for security&#10;RUN addgroup --system --gid 1001 vertx &amp;&amp; \&#10;    adduser --system --uid 1001 --gid 1001 vertx&#10;&#10;# Copy only the fat JAR from builder stage&#10;COPY --from=builder /build/target/*-fat.jar app.jar&#10;RUN chown -R vertx:vertx /app&#10;&#10;# Switch to non-root user&#10;USER vertx&#10;&#10;# Environment variables&#10;ENV LOG_LEVEL=INFO&#10;ENV SHUTDOWN_TIMEOUT_MS=30000&#10;&#10;# Expose the application port&#10;EXPOSE 8080&#10;&#10;# Set the entry point with Java 21 optimizations&#10;ENTRYPOINT [&quot;java&quot;, \&#10;    &quot;--enable-preview&quot;, \&#10;    &quot;--enable-native-access=ALL-UNNAMED&quot;, \&#10;    &quot;-XX:+UseZGC&quot;, \&#10;    &quot;-XX:+ZGenerational&quot;, \&#10;    &quot;-Djdk.virtualThreadScheduler.parallelism=16&quot;, \&#10;    &quot;-jar&quot;, &quot;app.jar&quot;]" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/docker/.dockerignore">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/docker/.dockerignore" />
              <option name="updatedContent" value="# Git&#10;.git&#10;.gitignore&#10;&#10;# Maven&#10;target/&#10;!target/*-fat.jar&#10;dependency-reduced-pom.xml&#10;&#10;# IDE files&#10;.idea/&#10;*.iml&#10;.vscode/&#10;.settings/&#10;.project&#10;.classpath&#10;&#10;# Logs&#10;*.log&#10;&#10;# OS files&#10;.DS_Store&#10;Thumbs.db" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/cresterida/gateway/Main.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/cresterida/gateway/Main.java" />
              <option name="originalContent" value="package com.cresterida.gateway;&#10;&#10;import io.vertx.core.Vertx;&#10;import io.vertx.core.VertxOptions;&#10;&#10;import org.apache.logging.log4j.LogManager;&#10;import org.apache.logging.log4j.Logger;&#10;import io.vertx.micrometer.Label;&#10;import io.vertx.micrometer.MicrometerMetricsOptions;&#10;import io.vertx.micrometer.VertxPrometheusOptions;&#10;import io.vertx.micrometer.backends.BackendRegistries;&#10;import java.util.concurrent.CountDownLatch;&#10;import java.util.concurrent.ExecutionException;&#10;import java.util.concurrent.TimeUnit;&#10;import java.util.concurrent.TimeoutException;&#10;&#10;public class Main {&#10;    private static final Logger logger = LogManager.getLogger(Main.class);&#10;    private static Vertx vertx;&#10;&#10;    public static void main(String args []) {&#10;        String currentLevel = System.getenv(&quot;LOG_LEVEL&quot;);&#10;        logger.info(currentLevel);&#10;&#10;&#10;        MicrometerMetricsOptions metricsOptions = new MicrometerMetricsOptions()&#10;                .setEnabled(true)&#10;                .setJvmMetricsEnabled(true)&#10;&#10;                .setPrometheusOptions(&#10;                  new VertxPrometheusOptions().setEnabled(true)&#10;                          .setStartEmbeddedServer(false))&#10;                .addLabels(Label.HTTP_METHOD, Label.HTTP_PATH, Label.HTTP_CODE);&#10;        // 5. Create Vertx with the explicit factory. This is the single source of truth.&#10;&#10;&#10;        vertx = Vertx.builder()&#10;                .with(new VertxOptions()&#10;                        .setMetricsOptions(metricsOptions))&#10;&#10;                .build();&#10;&#10;        var registry = BackendRegistries.getDefaultNow();&#10;&#10;        if (registry == null) {&#10;            logger.info(&quot;No backend registry available&quot;);&#10;        }&#10;        else {&#10;&#10;            logger.info(registry.getClass().getName());&#10;        }&#10;&#10;&#10;        // Check if this is the only Vert.x instance&#10;        try {&#10;            Vertx current = Vertx.currentContext() != null ? Vertx.currentContext().owner() : null;&#10;            logger.info( current);&#10;        } catch (Exception e) {&#10;            logger.info(&quot;No current Vert.x context&quot;);&#10;        }&#10;        // Deploy the API Gateway verticle&#10;        vertx.deployVerticle(new ApiGatewayVerticle())&#10;                .onSuccess(id -&gt; logger.info(&quot;Gateway started successfully&quot;))&#10;                .onFailure(err -&gt; {&#10;                    logger.error(err);&#10;                    System.exit(1);&#10;                });&#10;&#10;&#10;            setupShutdownHook(vertx);&#10;        printLogDetails();&#10;&#10;    }&#10;    private static void setupShutdownHook(Vertx vertx) {&#10;        Runtime.getRuntime().addShutdownHook(new Thread(() -&gt; {&#10;            System.out.println(&quot;Initiating shutdown sequence...&quot;);&#10;&#10;            try {&#10;                // First close Vert.x and wait synchronously&#10;                vertx.close()&#10;                        .toCompletionStage()&#10;                        .toCompletableFuture()&#10;                        .get(30, TimeUnit.SECONDS);&#10;&#10;                System.out.println(&quot;Vert.x shutdown completed&quot;);&#10;&#10;                // Ensure all loggers are flushed and closed&#10;                LogManager.shutdown(true);&#10;&#10;                System.out.println(&quot;Shutdown completed&quot;);&#10;&#10;            } catch (Exception e) {&#10;                System.err.println(&quot;Error during shutdown: &quot; + e.getMessage());&#10;                System.exit(1);&#10;            }&#10;        }));&#10;    }&#10;&#10;&#10;&#10;&#10;&#10;&#10;    static private void printLogDetails() {&#10;&#10;        logger.info(&quot;Logger Name: &quot; + logger.getName());&#10;        logger.info(&quot;Logger Level: &quot; + logger.getLevel());&#10;        logger.info(&quot;Logger Class: &quot; + logger.getClass().getName());&#10;    }&#10;&#10;&#10;}&#10;" />
              <option name="updatedContent" value="package com.cresterida.gateway;&#10;&#10;import io.vertx.core.Vertx;&#10;import io.vertx.core.VertxOptions;&#10;&#10;import org.apache.logging.log4j.LogManager;&#10;import org.apache.logging.log4j.Logger;&#10;import io.vertx.micrometer.Label;&#10;import io.vertx.micrometer.MicrometerMetricsOptions;&#10;import io.vertx.micrometer.VertxPrometheusOptions;&#10;import io.vertx.micrometer.backends.BackendRegistries;&#10;import java.util.concurrent.CountDownLatch;&#10;import java.util.concurrent.ExecutionException;&#10;import java.util.concurrent.TimeUnit;&#10;import java.util.concurrent.TimeoutException;&#10;&#10;public class Main {&#10;    private static final Logger logger = LogManager.getLogger(Main.class);&#10;    private static Vertx vertx;&#10;&#10;    public static void main(String args []) {&#10;        String currentLevel = System.getenv(&quot;LOG_LEVEL&quot;);&#10;        logger.info(currentLevel);&#10;&#10;&#10;        MicrometerMetricsOptions metricsOptions = new MicrometerMetricsOptions()&#10;                .setEnabled(true)&#10;                .setJvmMetricsEnabled(true)&#10;&#10;                .setPrometheusOptions(&#10;                  new VertxPrometheusOptions().setEnabled(true)&#10;                          .setStartEmbeddedServer(false))&#10;                .addLabels(Label.HTTP_METHOD, Label.HTTP_PATH, Label.HTTP_CODE);&#10;        // 5. Create Vertx with the explicit factory. This is the single source of truth.&#10;&#10;&#10;        vertx = Vertx.builder()&#10;                .with(new VertxOptions()&#10;                        .setMetricsOptions(metricsOptions))&#10;&#10;                .build();&#10;&#10;&#10;        var registry = BackendRegistries.getDefaultNow();&#10;&#10;        if (registry == null) {&#10;            logger.info(&quot;No backend registry available&quot;);&#10;        }&#10;        else {&#10;&#10;            logger.info(registry.getClass().getName());&#10;        }&#10;&#10;&#10;        // Check if this is the only Vert.x instance&#10;        try {&#10;            Vertx current = Vertx.currentContext() != null ? Vertx.currentContext().owner() : null;&#10;            logger.info( current);&#10;        } catch (Exception e) {&#10;            logger.info(&quot;No current Vert.x context&quot;);&#10;        }&#10;        // Deploy the API Gateway verticle&#10;        vertx.deployVerticle(new ApiGatewayVerticle())&#10;                .onSuccess(id -&gt; logger.info(&quot;Gateway started successfully&quot;))&#10;                .onFailure(err -&gt; {&#10;                    logger.error(err);&#10;                    System.exit(1);&#10;                });&#10;&#10;&#10;            setupShutdownHook(vertx);&#10;        printLogDetails();&#10;&#10;    }&#10;    private static void setupShutdownHook(Vertx vertx) {&#10;        Runtime.getRuntime().addShutdownHook(new Thread(() -&gt; {&#10;            System.out.println(&quot;Initiating shutdown sequence...&quot;);&#10;&#10;            try {&#10;                // First close Vert.x and wait synchronously&#10;                vertx.close()&#10;                        .toCompletionStage()&#10;                        .toCompletableFuture()&#10;                        .get(30, TimeUnit.SECONDS);&#10;&#10;                System.out.println(&quot;Vert.x shutdown completed&quot;);&#10;&#10;                // Ensure all loggers are flushed and closed&#10;                LogManager.shutdown(true);&#10;&#10;                System.out.println(&quot;Shutdown completed&quot;);&#10;&#10;            } catch (Exception e) {&#10;                System.err.println(&quot;Error during shutdown: &quot; + e.getMessage());&#10;                System.exit(1);&#10;            }&#10;        }));&#10;    }&#10;&#10;&#10;&#10;&#10;&#10;&#10;    static private void printLogDetails() {&#10;&#10;        logger.info(&quot;Logger Name: &quot; + logger.getName());&#10;        logger.info(&quot;Logger Level: &quot; + logger.getLevel());&#10;        logger.info(&quot;Logger Class: &quot; + logger.getClass().getName());&#10;    }&#10;&#10;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>